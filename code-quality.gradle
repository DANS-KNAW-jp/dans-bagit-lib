//this build file is responsible for all the configuration of code quality items, such as code coverage, syntax style checking, static bug finding, etc.
apply plugin: "jacoco"
apply plugin: "findbugs"
apply plugin: "pmd"

sourceSets {
  integrationTest {
      java {
          compileClasspath += main.output + test.output
          runtimeClasspath += main.output + test.output
          srcDir file('src/integration/java')
      }
  }
}

configurations {
  integrationTestCompile.extendsFrom testCompile
  integrationTestRuntime.extendsFrom testRuntime
}

task integrationTest(type: Test, dependsOn: "cloneConformanceSuite") {
  group "Verification"
  description "Runs the integration tests."
  testClassesDir = sourceSets.integrationTest.output.classesDir
  classpath = sourceSets.integrationTest.runtimeClasspath
  testLogging.showStandardStreams = true
}

jacocoTestReport.dependsOn integrationTest //include the integration tests in the code coverage reports
jacocoTestReport.dependsOn test //ensure the tests have run before generating a coverage report

check.dependsOn integrationTest //run the integration tests
check.dependsOn jacocoTestReport //run the code coverage reports
check.dependsOn javadoc //ensure javadocs are generated correctly

//ignore some of the code quality checks for tests since you can't always follow the best practices when testing
findbugsIntegrationTest.enabled = false
findbugsTest.enabled = false

pmdIntegrationTest.enabled = false
pmdTest.enabled = false

pmd {
  toolVersion = "5.5.4"
  ruleSets = [
    "java-basic", 
    "java-braces",
    "java-clone",
    "java-codesize",
    "java-design",
    "java-empty",
    "java-finalizers",
    "java-imports",
    "java-j2ee",
    "java-javabeans",
    "java-optimizations",
    "java-strictexception",
    "java-strings",
    "java-sunsecure",
    "java-typeresolution",
    "java-unnecessary",
    "java-unusedcode"
  ]
}

jacocoTestReport {
  reports {
      xml.enabled = true // coveralls plugin depends on xml format report
      html.enabled = true
  }
  afterEvaluate {
    classDirectories = files(classDirectories.files.collect {
        fileTree(dir: it, exclude: ['gov.loc.repository.bagit/domain/**',
          'gov.loc.repository.bagit/annotation/**',
          'gov.loc.repository.bagit/exceptions/**'])
    })
  }
}

cpdCheck {
    source = sourceSets.main.allJava
    reports {
        text.enabled = true
        xml.enabled = false
    }
}

dependencyCheck {
    skipTestGroups=true
    skipConfigurations=['findbugs','cpd'] //don't look for vulnerabilities in the build plugins
    outputDirectory="build/reports/OWASP"
}

//Keep this for easy viewing of html findbugs report
//tasks.withType(FindBugs) {
//  reports {
//      xml.enabled = false
//      html.enabled = true
//  }
//}

import java.util.Map.Entry;
task checkMessageBundle(){
  inputs.files(fileTree(dir: "src/main/resources", include: "**/MessageBundle*.properties"))
  outputs.dir("$buildDir/checkMessageBundle") //hack: define a output dir so gradle will check if up-to-date
  
  doLast{
    Set<String> messageKeys = new HashSet<>()
  
    inputs.getFiles().each{File file -> 
      file.eachLine {String line -> 
        if(line && !line.trim().startsWith('#')){
          String[] keyValue = checkMessageBundleLineIsCorrectlyFormatted(line, file)
          
          if(messageKeys.contains(keyValue[0])){
            throw new GradleException("Internationalization message bundle contains duplicate key [${keyValue[0]}]!")
          }
          messageKeys.add(keyValue[0])
        }
      }
    }
    
    checkAllMessageKeysAreUsed(messageKeys)
  }
}
check.dependsOn checkMessageBundle

String[] checkMessageBundleLineIsCorrectlyFormatted(String line, File file){
  String[] keyValue = line.split("=", 2)
  
  if(keyValue.size() != 2 || keyValue[1].isEmpty()){
    throw new GradleException("Line [${line}] in file [${file}] is not a valid entry for the internationalization message bundle!")
  }
  
  return keyValue
}

void checkAllMessageKeysAreUsed(Set<String> messageKeys){
  sourceSets.main.allJava.each { File file ->
    file.eachLine{ String line ->
      for(String key : messageKeys.clone()){
        if(line.contains(key)){
          messageKeys.remove(key)
        }
      }
    }
  }
  
  if(messageKeys.size() > 0){
    messageKeys.each{String key ->
      throw new GradleException("[${key}] is listed in the internationalization message bundle but never actually used!")
    }  
  }
}